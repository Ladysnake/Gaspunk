#version 120
//#extension GL_EXT_gpu_shader4 : require TODO make some varying values flat

varying vec4 vPosition;
varying vec2 texcoord;
varying mat4 gbufferModelViewInverse;
varying mat4 gbufferProjectionInverse;

bool invert(mat4 m, mat4 invOut) {
  mat4 inv;
  float det;
  int i;

    inv[0][0] = m[1][1]  * m[2][2] * m[3][3] -
             m[1][1]  * m[2][3] * m[3][2] -
             m[2][1]  * m[1][2]  * m[3][3] +
             m[2][1]  * m[1][3]  * m[3][2] +
             m[3][1] * m[1][2]  * m[2][3] -
             m[3][1] * m[1][3]  * m[2][2];

    inv[1][0] = -m[1][0]  * m[2][2] * m[3][3] +
              m[1][0]  * m[2][3] * m[3][2] +
              m[2][0]  * m[1][2]  * m[3][3] -
              m[2][0]  * m[1][3]  * m[3][2] -
              m[3][0] * m[1][2]  * m[2][3] +
              m[3][0] * m[1][3]  * m[2][2];

    inv[2][0] = m[1][0]  * m[2][1] * m[3][3] -
             m[1][0]  * m[2][3] * m[3][1] -
             m[2][0]  * m[1][1] * m[3][3] +
             m[2][0]  * m[1][3] * m[3][1] +
             m[3][0] * m[1][1] * m[2][3] -
             m[3][0] * m[1][3] * m[2][1];

    inv[3][0] = -m[1][0]  * m[2][1] * m[3][2] +
               m[1][0]  * m[2][2] * m[3][1] +
               m[2][0]  * m[1][1] * m[3][2] -
               m[2][0]  * m[1][2] * m[3][1] -
               m[3][0] * m[1][1] * m[2][2] +
               m[3][0] * m[1][2] * m[2][1];

    inv[0][1] = -m[0][1]  * m[2][2] * m[3][3] +
              m[0][1]  * m[2][3] * m[3][2] +
              m[2][1]  * m[0][2] * m[3][3] -
              m[2][1]  * m[0][3] * m[3][2] -
              m[3][1] * m[0][2] * m[2][3] +
              m[3][1] * m[0][3] * m[2][2];

    inv[1][1] = m[0][0]  * m[2][2] * m[3][3] -
             m[0][0]  * m[2][3] * m[3][2] -
             m[2][0]  * m[0][2] * m[3][3] +
             m[2][0]  * m[0][3] * m[3][2] +
             m[3][0] * m[0][2] * m[2][3] -
             m[3][0] * m[0][3] * m[2][2];

    inv[2][1] = -m[0][0]  * m[2][1] * m[3][3] +
              m[0][0]  * m[2][3] * m[3][1] +
              m[2][0]  * m[0][1] * m[3][3] -
              m[2][0]  * m[0][3] * m[3][1] -
              m[3][0] * m[0][1] * m[2][3] +
              m[3][0] * m[0][3] * m[2][1];

    inv[3][1] = m[0][0]  * m[2][1] * m[3][2] -
              m[0][0]  * m[2][2] * m[3][1] -
              m[2][0]  * m[0][1] * m[3][2] +
              m[2][0]  * m[0][2] * m[3][1] +
              m[3][0] * m[0][1] * m[2][2] -
              m[3][0] * m[0][2] * m[2][1];

    inv[0][2] = m[0][1]  * m[1][2] * m[3][3] -
             m[0][1]  * m[1][3] * m[3][2] -
             m[1][1]  * m[0][2] * m[3][3] +
             m[1][1]  * m[0][3] * m[3][2] +
             m[3][1] * m[0][2] * m[1][3] -
             m[3][1] * m[0][3] * m[1][2];

    inv[1][2] = -m[0][0]  * m[1][2] * m[3][3] +
              m[0][0]  * m[1][3] * m[3][2] +
              m[1][0]  * m[0][2] * m[3][3] -
              m[1][0]  * m[0][3] * m[3][2] -
              m[3][0] * m[0][2] * m[1][3] +
              m[3][0] * m[0][3] * m[1][2];

    inv[2][2] = m[0][0]  * m[1][1] * m[3][3] -
              m[0][0]  * m[1][3] * m[3][1] -
              m[1][0]  * m[0][1] * m[3][3] +
              m[1][0]  * m[0][3] * m[3][1] +
              m[3][0] * m[0][1] * m[1][3] -
              m[3][0] * m[0][3] * m[1][1];

    inv[3][2] = -m[0][0]  * m[1][1] * m[3][2] +
               m[0][0]  * m[1][2] * m[3][1] +
               m[1][0]  * m[0][1] * m[3][2] -
               m[1][0]  * m[0][2] * m[3][1] -
               m[3][0] * m[0][1] * m[1][2] +
               m[3][0] * m[0][2] * m[1][1];

    inv[0][3] = -m[0][1] * m[1][2] * m[2][3] +
              m[0][1] * m[1][3] * m[2][2] +
              m[1][1] * m[0][2] * m[2][3] -
              m[1][1] * m[0][3] * m[2][2] -
              m[2][1] * m[0][2] * m[1][3] +
              m[2][1] * m[0][3] * m[1][2];

    inv[1][3] = m[0][0] * m[1][2] * m[2][3] -
             m[0][0] * m[1][3] * m[2][2] -
             m[1][0] * m[0][2] * m[2][3] +
             m[1][0] * m[0][3] * m[2][2] +
             m[2][0] * m[0][2] * m[1][3] -
             m[2][0] * m[0][3] * m[1][2];

    inv[2][3] = -m[0][0] * m[1][1] * m[2][3] +
               m[0][0] * m[1][3] * m[2][1] +
               m[1][0] * m[0][1] * m[2][3] -
               m[1][0] * m[0][3] * m[2][1] -
               m[2][0] * m[0][1] * m[1][3] +
               m[2][0] * m[0][3] * m[1][1];

    inv[3][3] = m[0][0] * m[1][1] * m[2][2] -
              m[0][0] * m[1][2] * m[2][1] -
              m[1][0] * m[0][1] * m[2][2] +
              m[1][0] * m[0][2] * m[2][1] +
              m[2][0] * m[0][1] * m[1][2] -
              m[2][0] * m[0][2] * m[1][1];

    det = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] + m[0][2] * inv[2][0] + m[0][3] * inv[3][0];

    if (det == 0)
        return false;

    det = 1.0 / det;

    for (i = 0; i < 16; i++)
        invOut[i] = inv[i] * det;
    return true;
}

void main(void) {
  gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
  vPosition = gl_Position;
  texcoord = vec2(gl_MultiTexCoord0);
  invert(gl_ModelViewMatrix, gbufferModelViewInverse);
  invert(gl_ProjectionMatrix, gbufferProjectionInverse);
}
